<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Before running the application you will need a working PostgreSQL installation and a valid DSN (data source name) for connecting to the database.</p>
<p>Please open the <code>cmd/api/main.go</code> file and edit the <code>db-dsn</code> command-line flag to include your valid DSN as the default value.</p>
<pre>
flag.StringVar(&amp;cfg.db.dsn, "db-dsn", "YOUR DSN GOES HERE", "postgreSQL DSN")
</pre>
<p>Note that this DSN must be in the format <code>user:pass@localhost:port/db</code> and <strong>not</strong> be prefixed with <code>postgres://</code>.</p>
<p>Make sure that you're in the root of the project directory, fetch the dependencies with <code>go mod tidy</code>, then run the application using <code>go run ./cmd/api</code>:</p>
<pre>
$ go mod tidy
$ go run ./cmd/api
</pre>
<p>If you make a request to the <code>GET /status</code> endpoint using <code>curl</code> you should get a response like this:</p>
<pre>
$ curl -i localhost:4444/status
<samp>HTTP/1.1 200 OK
Content-Type: application/json
Date: Mon, 09 May 2022 20:46:37 GMT
Content-Length: 23

{
    "Status": "OK",
}</samp></pre>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>assets</code></strong></td>
<td>Contains the non-code assets for the application.</td>
</tr>
<tr>
<td><code>↳ assets/emails/</code></td>
<td>Contains email templates.</td>
</tr>
<tr>
<td><code>↳ assets/migrations/</code></td>
<td>Contains SQL migrations.</td>
</tr>
<tr>
<td><code>↳ assets/efs.go</code></td>
<td>Declares an embedded filesystem containing all the assets.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>cmd/api</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/api/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/api/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/api/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/api/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/api/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
<tr>
<td><code>↳ cmd/api/server.go</code></td>
<td>Contains a helper functions for starting and gracefully shutting down the server.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/database/</code></td>
<td>Contains your database-related code (setup, connection and queries).</td>
</tr>
<tr>
<td><code>↳ internal/funcs/</code></td>
<td>Contains custom template functions.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding JSON requests.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for sending JSON responses.</td>
</tr>
<tr>
<td><code>↳ internal/smtp/</code></td>
<td>Contains a SMTP sender implementation.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via command-line flags in <code>main.go</code>.</p>
<p>You can try this out by using the <code>--http-port</code> flag to configure the network port that the server is listening:</p>
<pre>
$ go run ./cmd/api --http-port=9999
</pre>
<p>Feel free to adapt the <code>main()</code> function to parse additional command-line flags and store their values in the <code>config</code> struct. For example, to add a configuration setting to enable a 'debug mode' in your application you could do this:</p>
<pre>
type config struct {
    httpPort  int
    debug     bool
}

...

func main() {
    var cfg config

    flag.IntVar(&amp;cfg.httpPort, "http-port", 4444, "port to listen on for HTTP requests")
    flag.BoolVar(&amp;cfg.debug, "debug", false, "enable debug mode")

    flag.Parse()

    ...
}
</pre>
<p>If you don't want to use command-line flags for configuration, feel free to adapt the code so that the <code>config</code> struct is populated from environment variables or a settings file instead.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</pre>
<p>Handlers are defined in the <code>cmd/api/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>main()</code> function <code>cmd/api/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/api/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> is used for routing. Routes are defined in the <code>routes()</code> method in the <code>cmd/api/routes.go</code> file. For example:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    return mux
}
</pre>
<p>For more information about HttpRouter and example usage, please see the <a href="https://github.com/julienschmidt/httprouter">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/api/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</pre>
<p>You can then use this middleware by wrapping the router before returning it from the <code>routes()</code> method, like so:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    // Wrap the router with middleware.
    return app.yourMiddlware(app.yourOtherMiddleware(mux))
}
</pre>
<p>It's possible to use middleware on specific routes only:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)

    // Wrap this handler with route-specific middleware. Note that when 
    // wrapping handler functions with route-specific middleware that you
    // need to convert them to a http.Handler by using the http.HandlerFunc()
    // adapter. Like so: 
    mux.Handler("GET", "/your/other/path", app.yourOtherMiddleware(http.HandlerFunc(app.yourOtherHandler)))
    
    return app.yourMiddleware(mux)
}
</pre>
<h2>Sending JSON responses</h2>
<p>JSON responses and a specific HTTP status code can be sent using the <code>response.JSON()</code> function. The <code>data</code> parameter can be any JSON-marshalable type.</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<h2>Parsing JSON requests</h2>
<p>HTTP requests containing a JSON body can be decoded using the <code>request.DecodeJSON()</code> function. For example, to decode JSON into an <code>input</code> struct:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Note: The target decode destination passed to <code>request.DecodeJSON()</code> (which in the example above is <code>&amp;input</code>) must be a non-nil pointer.</p>
<p>The <code>request.DecodeJSON()</code> function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the <code>app.badRequest()</code> helper.</p>
<h2>Validating JSON requests</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age &gt;= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}    
</pre>
<p>The <code>app.failedValidation()</code> helper will send a <code>422</code> status code along with any validation error messages. For the example above, the JSON response will look like this:</p>
<pre>
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}    
</pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Working with the database</h2>
<p>This codebase is set up to use PostgreSQL with the <a href="https://github.com/lib/pq">lib/pq</a> driver. You can control which database you connect to using the <code>--db-dsn</code> command-line flag when starting the application to pass in a DSN, or by adapting the default value in <code>main()</code>.</p>
<p>The codebase is also configured to use <a href="https://github.com/jmoiron/sqlx">jmoiron/sqlx</a>, so you have access to the whole range of sqlx extensions as well as the standard library <code>Exec()</code>, <code>Query()</code> and <code>QueryRow()</code> methods .</p>
<p>The database is available to your handlers, middleware and helpers via the <code>application</code> struct. If you want, you can access the database and carry out queries directly. For example:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", "Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Generally though, it's recommended to isolate your database logic in the <code>internal/database</code> package and extend the <code>DB</code> type to include your own methods. For example, you could create a <code>internal/database/people.go</code> file containing code like:</p>
<pre>
type Person struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Age   int    `db:"age"`
}

func (db *DB) NewPerson(name string, age int) error {
    _, err := db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", name, age)
    return err
}

func (db *DB) GetPerson(id int) (Person, error) {
    var person Person
    err := db.Get(&amp;person, "SELECT * FROM people WHERE id = $1", id)
    return person, err
}
</pre>
<p>And then call this from your handlers:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.NewPerson("Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<h2>Managing SQL migrations</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily create and work with database migrations:</p>
<table>
<tbody>
<tr>
<td><code>$ make migrations/new name=add_example_table</code></td>
<td>Create a new database migration in the <code>assets/migrations</code> folder.</td>
</tr>
<tr>
<td><code>$ make migrations/up</code></td>
<td>Apply all up migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/down</code></td>
<td>Apply all down migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/goto version=N</code></td>
<td>Migrate up or down to a specific migration (where N is the migration version number).</td>
</tr>
<tr>
<td><code>$ make migrations/force version=N</code></td>
<td>Force the database to be specific version without running any migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/version</code></td>
<td>Display the currently in-use migration version.</td>
</tr>
</tbody>
</table>
<p>Hint: You can run <code>$ make help</code> at any time for a reminder of these commands.</p>
<p>These <code>Makefile</code> tasks are simply wrappers around calls to the <code>github.com/golang-migrate/migrate/v4/cmd/migrate</code> tool. For more information, please see the <a href="https://github.com/golang-migrate/migrate/tree/master/cmd/migrate">official documentation</a>.</p>
<p>By default all 'up' migrations are automatically run on application startup using embeded files from the <code>assets/migrations</code> directory. You can disable this by using the command-line flag <code>--db-automigrate=false</code> when running the application.</p>
<h2 id="sending-emails">Sending emails</h2>
<p>The application is configured to support sending of emails via SMTP.</p>
<p>Email templates should be defined as files in the <code>assets/emails</code> folder. Each file should contain named templates for the email subject, plaintext body and — optionally — HTML body.</p>
<pre>
{{define "subject"}}Example subject{{end}}

{{define "plainBody"}} 
This is an example body
{{end}}
    
{{define "htmlBody"}}
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width" /&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;This is an example body&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
{{end}}
</pre>
<p>A further example can be found in the <code>assets/emails/example.tmpl</code> file. Note that your email templates automatically have access to the custom template functions defined in the <code>internal/funcs</code> package.</p>
<p>Emails can be sent from your handlers using <code>app.mailer.Send()</code>. For example, to send an email to <code>alice@example.com</code> containing the contents of the <code>assets/emails/example.tmpl</code> file:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    data := map[string]any{"Name": "Alice"}

    err := app.mailer.Send("alice@example.com", data, "example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
        return
    }

   ...
}
</pre>
<p>Note: The second parameter to <code>Send()</code> should be a map or struct containing any dynamic data that you want to render in the email template.</p>
<p>The SMTP host, port, username, password and sender details can be configured using the <code>--smtp-host</code>, <code>--smtp-port</code>, <code>--smtp-username</code>, <code>--smtp-password</code> and <code>--smtp-from</code> command-line flags when starting the application, or by adapting the default values in <code>cmd/api/main.go</code>.</p>
<p>You may wish to use <a href="https://mailtrap.io/">Mailtrap</a> or a similar tool for development purposes.</p>
<h2>Custom template functions</h2>
<p>Custom template functions are defined in <code>internal/funcs/funcs.go</code> and are automatically made available to your email templates when you use <code>app.mailer.Send()</code> .</p>
<p>The following custom template functions are already included by default:</p>
<table>
<tbody>
<tr>
<td><code>now</code></td>
<td>Returns the current time.</td>
</tr>
<tr>
<td><code>timeSince arg1</code></td>
<td>Returns the time elapsed since arg1.</td>
</tr>
<tr>
<td><code>timeUntil arg2</code></td>
<td>Returns the time until arg1.</td>
</tr>
<tr>
<td><code>formatTime arg1 arg2</code></td>
<td>Returns the time arg2 as formatted using the pattern arg1.</td>
</tr>
<tr>
<td><code>approxDuration arg1</code></td>
<td>Returns the approximate duration of arg1 in a 'human-friendly' format ("3 seconds", "2 months", "5 years") etc.</td>
</tr>
<tr>
<td><code>uppercase arg1</code></td>
<td>Returns arg1 converted to uppercase.</td>
</tr>
<tr>
<td><code>lowercase arg1</code></td>
<td>Returns arg1 converted to lowercase.</td>
</tr>
<tr>
<td><code>pluralize arg1 arg2 arg3</code></td>
<td>If arg1 equals 1 then return arg2, otherwise return arg3.</td>
</tr>
<tr>
<td><code>slugify arg1</code></td>
<td>Returns the lowercase of arg1 with all non-ASCII characters and punctuation removed (expect underscores and hyphens). Whitespaces are also replaced with a hyphen.</td>
</tr>
<tr>
<td><code>safeHTML arg1</code></td>
<td>Output the verbatim value of arg1 without escaping the content. This should only be used when arg1 is from a trusted source.</td>
</tr>
<tr>
<td><code>join arg1 arg2</code></td>
<td>Returns the values in arg1 joined using the separator arg2.</td>
</tr>
<tr>
<td><code>containsString arg1 arg2</code></td>
<td>Returns true if arg1 contains the string value arg2.</td>
</tr>
<tr>
<td><code>incr arg1</code></td>
<td>Increments arg1 by 1.</td>
</tr>
<tr>
<td><code>decr arg1</code></td>
<td>Decrements arg1 by 1.</td>
</tr>
<tr>
<td><code>formatInt arg1</code></td>
<td>Returns arg1 formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>formatFloat arg1 arg2</code></td>
<td>Returns arg1 rounded to arg2 decimal places and formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>yesno arg1</code></td>
<td>Returns "Yes" if arg1 is true, or "No" if arg1 is false.</td>
</tr>
<tr>
<td><code>urlSetParam arg1 arg2 arg3</code></td>
<td>Returns the URL arg1 with the key arg2 and value arg3 added to the query string parameters.</td>
</tr>
<tr>
<td><code>urlDelParam arg1 arg2</code></td>
<td>Returns the URL arg1 with the key arg2 (and corresponding value) removed from the query string parameters.</td>
</tr>
</tbody>
</table>
<p>To add another custom template function, define the function in <code>internal/funcs/funcs.go</code> and add it to the <code>TemplateFuncs</code> map. For example:</p>
<pre>
var TemplateFuncs = template.FuncMap{
    ...
    "yourFunction": yourFunction, 
}

func yourFunction(s string) (string, error) {
    // Do something...
}
</pre>
<h2>Running background tasks</h2>
<p>A <code>backgroundTask()</code> helper is included in the <code>cmd/api/helpers.go</code> file. You can call this in your handlers, helpers and middleware to run any logic in a separate background goroutine. This useful for things like sending emails, or completing slow-running jobs.</p>
<p>You can call it like so:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    app.backgroundTask(func() {
        // The logic you want to execute in a background task goes here...
    })
    
    ...
}
</pre>
<p>Using the <code>backgroundTask()</code> helper will automatically recover any panics in the background task logic, and when performing a graceful shutdown the application will wait for any background tasks to finish running before it exits.</p>
<h2>Application version</h2>
<p>The application version number is defined in a <code>Get()</code> function in the <code>internal/version/version.go</code> file. Feel free to change this as necessary.</p>
<pre>
package version

func Get() string {
    return "0.0.1"
}
</pre>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>github.com/mofodox/anymail</code>. If you want to change this please find and replace all instances of <code>github.com/mofodox/anymail</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
AutoHTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Background tasks
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Routing
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Handlers
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Notifications
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
